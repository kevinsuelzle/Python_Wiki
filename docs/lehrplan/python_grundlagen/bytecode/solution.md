# Antworten zu den Recherche- und Diskussionsaufgaben

### **1. Grundlagen des Python-Interpreters**

  - **Definition**: Ein Interpreter, der Python-Code liest und ausführt.
  - **Funktionsweise**: Übersetzt Python-Code in Bytecode, den er dann ausführt.
  - **Interaktive Shell**: Erlaubt direkte Eingabe und Ausführung von Python-Code.
  - **Skriptausführung**: Führt geschriebene Python-Skripte aus.
  - **Fehlermeldungen**: Gibt Fehler und Ausnahmen während der Ausführung aus.

### **2. Bytecode in Python verstehen**

   - **Zwischenstufe**: Bytecode ist eine Zwischenrepräsentation des Python-Codes.
   - **Kompilierung**: Python-Code wird zuerst in Bytecode kompiliert.
   - **Unabhängigkeit**: Bytecode ist plattformunabhängig.
   - **Python Virtual Machine**: Bytecode wird von der PVM ausgeführt.
   - **Optimierung**: Bytecode ermöglicht bestimmte Optimierungen.

### **3. Python und Plattformunabhängigkeit**

   - **Definition**: Python-Code läuft auf verschiedenen Betriebssystemen.
   - **Bytecode-Ebene**: Unabhängigkeit durch Kompilierung in Bytecode.
   - **Python Interpreter**: Unterschiedliche Interpreter für verschiedene Systeme.
   - **Keine Änderung nötig**: Gleicher Python-Code auf unterschiedlichen Systemen.
   - **Breite Anwendbarkeit**: Eignet sich für cross-platform Entwicklung.

### **4. Einführung in Python Virtual Machine (PVM)**

   - **Was ist PVM**: Interpretiert und führt Python-Bytecode aus.
   - **Unabhängigkeit**: Macht Python plattformunabhängig.
   - **Ausführung**: Verwandelt Bytecode in Maschinencode.
   - **Portabilität**: Erlaubt Python-Code-Ausführung auf verschiedenen Systemen.
   - **Kernkomponente**: Zentraler Bestandteil von Python's Ausführungsprozess.

### **5. Python-Interpreter: CPython vs. PyPy**

   - **CPython**: Standard-Interpreter, direkt von Python.org.
     - **Direkte Ausführung**: Kompiliert Python-Code in Bytecode und führt ihn aus.
     - **Erweiterbarkeit**: Ermöglicht Erweiterungen in C.
   - **PyPy**: Alternative Implementierung mit JIT-Kompilierung.
     - **Performance**: Oft schneller durch JIT-Optimierung.
     - **Speicherbedarf**: Kann mehr Speicher benötigen als CPython.
